
函数式编程是一种基于函数计算的软件开发方法。像数学一样，函数在编程中通过输入产生输出。你可以通过多种方式组合基本功能来构建越来越复杂的程序。

函数式编程遵循几个核心原则：

独立于程序状态或全局变量，只依赖于传递给它们的参数进行计算

限制更改程序状态，避免更改保存数据的全局对象

对程序的副作用尽量小

函数式编程式将程序分成小的、可测试的部分，本节介绍 JavaScript 中函数式编程的基本原则。

## 1.学习函数式编程

函数式编程是一种解决方案简单，功能独立，对作用域外没有任何副作用的编程范式。

`INPUT -> PROCESS -> OUTPUT`

函数式编程：

1）功能独立——不依赖于程序的状态（比如可能发生变化的全局变量）；

2）纯函数——同一个输入永远能得到同一个输出；

3）有限的副作用——可以严格地限制函数外部对状态的更改导致的状态变化。


## 2.了解函数式编程术语

FCC 团队需求有变更，现在想要两种茶：绿茶（green tea）和红茶（black tea）。事实证明，用户需求变更是很常见的。

基于以上信息，我们需要重构上一节挑战中的getTea函数来处理多种茶的请求。我们可以修改getTea接受一个函数作为参数，使它能够修改茶的类型。这让getTea更灵活，也使需求变更时为程序员提供更多控制权。

首先，我们将介绍一些术语：

Callbacks是被传递到另一个函数中调用的函数。你应该已经在其他函数中看过这个写法，例如在`filter`中，回调函数告诉 JavaScript 以什么规则过滤数组。

函数就像其他正常值一样，可以赋值给变量、传递给另一个函数，或从其它函数返回，这种函数叫做`first class`函数。在 JavaScript 中，所有函数都是`first class`函数。

将函数为参数或返回值的函数叫做higher order函数。

当函数传递给另一个函数或从另一个函数返回时，那些传入或返回的函数可以叫做lambda。

## 3.了解使用命令式编程的危害

函数式编程是一种好习惯，它能让代码管理更简单，不受隐藏 bug 影响。在我们开始函数式编程之前，为了更好的突显可能遇到的问题，我们先看看命令式编程。

类似在英语（和许多其他语言）中，命令式时态用于给出命令，编程中的命令式是给计算机一组语句来执行任务。

这些语句通常会改变程序的状态，例如更新全局变量，典型的例子就是写一个for循环，它给出了迭代数组索引的精确方向。

相反，函数式编程是声明式编程的一种形式，通过调用方法或函数来告诉计算机要做什么。

JavaScript 提供了许多处理常见任务的方法，所以你无需写出计算机应如何执行它们。例如，你可以用map函数替代上面提到的for循环来处理数组迭代。这有助于避免语义错误，如调试章节介绍的"Off By One Errors"。

考虑这样的场景：你正在浏览器中浏览网页，并想操作你打开的标签。下面我们来试试用面向对象的思路来描述这种情景。

窗口对象由选项卡组成，通常会打开多个窗口。窗口对象中每个打开网站的标题都保存在一个数组中。在对浏览器进行了如打开新标签、合并窗口、关闭标签之类的操作后，你需要输出所有打开的标签。关掉的标签将从数组中删除，新打开的标签（为简单起见）则添加到数组的末尾。

代码编辑器中显示了此功能的实现，其中包含tabOpen()，tabClose()，和join()函数。tabs数组是窗口对象的一部分用于储存打开页面的名称。

说明
在编辑器中运行代码。它使用了有副作用的方法，导致输出错误。打开标签的最终列表应该是['FB', 'Gitter', 'Reddit', 'Twitter', 'Medium', 'new tab', 'Netflix', 'YouTube', 'Vine', 'GMail', 'Work mail', 'Docs', 'freeCodeCamp', 'new tab']但输出会略有不同。

仔细阅读代码，看看你是否能找出问题所在，然后进入下一个挑战，了解更多信息。

## 4.使用函数式编程避免突变和副作用

如果你还没想通，上一个挑战的问题出在tabClose()函数里的splice。不幸的是，splice修改了调用它的原始数组，所以第二次调用它时是基于修改后的数组，才给出了意料之外的结果。

这是一个小例子，还有更广义的定义——你在变量，数组或对象上调用一个函数，这个函数会改变对象中的变量或其他东西。

函数式编程的核心原则之一是不改变任何东西。变化会导致错误。如果一个函数不改变传入的参数、全局变量等数据，那么它造成问题的可能性就会小很多。

前面的例子没有任何复杂的操作，但是`splice`方法改变了原始数组，导致 bug 产生。

回想一下，在函数式编程中，改变或变更叫做`mutation`，这种改变的结果叫做“副作用”（`side effect`）。理想情况下，函数应该是不会产生任何副作用的`pure function`。

让我们尝试掌握这个原则：不要改变代码中的任何变量或对象。

## 5.传递参数以避免函数中的外部依赖

最后一个挑战是更接近函数式编程原则的挑战，但是仍然缺少一些东西。

虽然我们没有改变全局变量值，但在没有全局变量fixedValue情况下，incrementer函数将不起作用。

函数式编程的另一个原则是：总是显式声明依赖关系。如果函数依赖于一个变量或对象，那么将该变量或对象作为参数直接传递到函数中。

这样做会有很多好处，其中一点是让函数更容易测试，因为你确切地知道参数是什么，并且这个参数也不依赖于程序中的任何其他内容。

其次，这样做可以让你更加自信地更改，删除或添加新代码。因为你很清楚哪些是可以改的，哪些是不可以改的，这样你就知道哪里可能会有潜在的陷阱。

最后，无论代码的哪一部分执行它，函数总是会为同一组输入生成相同的输出。

## 6.在函数中重构全局变量

目前为止，我们已经看到了函数式编程的两个原则：

1) 不要更改变量或对象——创建新变量和对象，并在需要时从函数返回它们。

2) 声明函数参数——函数内的任何计算仅取决于参数，而不取决于任何全局对象或变量。

给数字增加 1 不够刺激，我们可以在处理数组或更复杂的对象时应用这些原则。

## 7.使用 map 方法从数组中提取数据

目前为止，我们已经学会了使用纯函数来避免程序中的副作用。此外，我们已经看到函数的值仅取决于其输入参数。

这仅仅是个开始。顾名思义，函数式编程以函数理论为中心。

能够将它们作为参数传递给其他函数，和从另一个函数返回一个函数是有意义的。函数在 JavaScript 中被视为`First Class Objects`，它们可以像任何其他对象一样使用。它们可以保存在变量中，存储在对象中，也可以作为函数参数传递。

让我们从一些简单的数组函数开始，这些函数是数组对象原型上的方法。在本练习中，我们来了解下数组的map方法（即`Array.prototype.map()`）。

请记住，`map`方法是迭代数组中每一项的方式之一。在对每个元素应用回调函数后，它会创建一个新数组(不改变原来的数组)。

## 8.在原型上实现 map 方法

我们之前用map方法（即Array.prototype.map()）返回一个与调用它的数组长度相同的数组。只要它的回调函数不改变原始数组，它就不会改变原始数组。

换句话说，map是一个纯函数，它的输出仅取决于输入的数组和作为参数传入的回调函数。

为了加深对map方法的理解，现在我们来用for或Array.prototype.forEach()自己实现一下这个方法。

注意：纯函数可以改变其作用域内定义的局部变量，但我们最好不要这样做。


## 9.使用 filter 方法从数组中提取数据

另一个有用的数组方法是`filter()`（即`Array.prototype.filter()`）。`filter`方法会返回一个长度不大于原始数组的新数组。

和`map`一样，`Filter`不会改变原始数组，它接收一个回调函数，将回调内的逻辑应用于数组的每个元素。新数组包含根据回调函数内条件返回 true 的元素。

## 10.在原型上实现 filter 方法

为了加深对filter的理解，现在我们来自己实现一下Array.prototype.filter()方法。

可以用for循环或Array.prototype.forEach()。

请注意：纯函数可以改变其作用域内定义的局部变量，但我们最好不要这样做。


## 11.使用 slice 方法返回数组的一部分

slice方法可以从已有数组中返回指定元素。它接受两个参数，第一个规定从何处开始选取，第二个规定从何处结束选取（不包括该元素）。如果没有传参，则默认为从数组的开头开始到结尾结束，这是复制整个数组的简单方式。slice返回一个新数组，不会修改原始数组。

举个例子：
```js
var arr = ["Cat", "Dog", "Tiger", "Zebra"];
var newArray = arr.slice(1, 3);
// 将新数组设置为 ["Dog", "Tiger"]
```

## 12.使用 slice 而不是 splice 从数组中移除元素

使用数组时经常遇到要删除一些元素并保留数组剩余部分的情况。为此，JavaScript 提供了splice方法，它接收两个参数：从哪里开始删除项目的索引，和要删除的项目数。如果没有提供第二个参数，默认情况下是移除到结尾的元素。但splice方法会改变调用它的原始数组。举个例子：
```js
var cities = ["Chicago", "Delhi", "Islamabad", "London", "Berlin"];
cities.splice(3, 1); // 返回 "London" 并将它从 cities 数组删除
// cities 现在是 ["Chicago", "Delhi", "Islamabad", "Berlin"]
```
正如我们在上一次挑战中看到的那样，slice方法不会改变原始数组，而是返回一个可以保存到变量中的新数组。回想一下，slice方法接收两个参数，从开始索引开始选取到结束（不包括该元素），并在新数组中返回这些元素。使用slice方法替代splice有助于避免数组变化产生的副作用。

## 13.使用 concat 方法组合两个数组


`Concatenation`意思是将元素连接到尾部。同理，JavaScript 为字符串和数组提供了concat方法。对数组来说，在一个数组上调用concat方法，然后提供另一个数组作为参数添加到第一个数组末尾，返回一个新数组，不会改变任何一个原始数组。举个例子：
```js
[1, 2, 3].concat([4, 5, 6]);
// 返回新数组 [1, 2, 3, 4, 5, 6]
```

## 14.使用 concat 而不是 push 将元素添加到数组的末尾

函数式编程就是创建和使用 non-mutating 函数。

最后一个挑战介绍了`concat`方法，这是一种在不改变原始数组的前提下，将数组组合成新数组的方法。将concat方法与push方法做比较，Push将元素添加到调用它的数组的末尾，这样会改变该数组。举个例子：
```js
var arr = [1, 2, 3];
arr.push([4, 5, 6]);
// arr 变成了 [1, 2, 3, [4, 5, 6]]
// 不是函数式编程
```
Concat方法可以将新项目添加到数组末尾，而不产生任何变更副作用。

## 15.使用 reduce 方法分析数据

`reduce()`（即Array.prototype.reduce()），是 JavaScript 所有数组操作中最通用的方法。几乎可以用reduce方法解决所有数组处理问题。

filter和map方法不支持对数组中两个不同元素的交互。举个例子，如果你想把数组中的元素拿来比较或者相加，用filter和map是做不到的。

reduce方法允许更通用的数组处理方式，而且filter和map方法都可以当作是reduce的特殊实现。

然而，在我们介绍它们的特殊实现之前，我们先来练习使用reduce。

## 16.使用 sort 方法按字母顺序给数组排序

sort方法可以根据回调函数对数组元素进行排序。

举个例子：
```js
function ascendingOrder(arr) {
  return arr.sort(function(a, b) {
    return a - b;
  });
}
ascendingOrder([1, 5, 2, 3, 4]);
// Returns [1, 2, 3, 4, 5]

function reverseAlpha(arr) {
  return arr.sort(function(a, b) {
    return a < b;
  });
}
reverseAlpha(['l', 'h', 'z', 'b', 's']);
// 返回 ['z', 's', 'l', 'h', 'b']
```
注意：提倡使用回调函数来指定如何对数组项进行排序。JavaScript 的默认排序算法是按照 Unicode 字符编码排序的，所以可能会返回意料之外的结果。




## 17.在不更改原始数组的前提下返回排序后的数组

sort方法会产生改变原始数组中元素顺序的副作用。换句话说，它会改变数组的位置。避免这种情况的一种方法是先将空数组连接到正在排序的数组上（记住concat返回一个新数组），再用sort方法。

## 18.使用 split 方法将字符串拆分成数组

`split`方法用于把字符串分割成字符串数组，接收一个分隔符参数，分隔符可以是用于分解字符串或正则表达式的字符。举个例子，如果分隔符是空格，你会得到一个单词数组；如果分隔符是空字符串，你会得到一个由字符串中每个字符组成的数组。

下面是两个用空格分隔一个字符串的例子，另一个是用数字的正则表达式分隔：
```js
var str = "Hello World";
var bySpace = str.split(" ");
// Sets bySpace to ["Hello", "World"]

var otherString = "How9are7you2today";
var byDigits = str.split(/\d/);
// Sets byDigits to ["How", "are", "you", "today"]
```
因为字符串是固定的，split方法可以更简单的操作它们。
## 19.使用 join 方法将数组组合成字符串

join方法用来把数组中的所有元素放入一个字符串，并通过指定的分隔符参数进行分隔。

举个例子：
```js
var arr = ["Hello", "World"];
var str = arr.join(" ");
// Sets str to "Hello World"
```


## 20.应用函数式编程将字符串转换为URL片段

最后几个挑战中涵盖了许多符合函数式编程原则并在处理数组和字符串中非常有用的方法。我们还学习了强大的、可以将问题简化为更简单形式的reduce方法，从计算平均值到排序，任何数组操作都可以用它来实现。回想一下，map和filter方法都是reduce的特殊实现。

让我们把学到的知识结合起来解决一个实际问题。

许多内容管理站点（CMS）为了让添加书签更简单，会将帖子的标题添加到 URL 上。举个例子，如果你写了一篇标题为 "Stop Using Reduce" 的帖子，URL很可能会包含标题字符串的某种形式 (如：".../stop-using-reduce")，你可能已经在 freeCodeCamp 网站上注意到了这一点。

***

填写urlSlug函数，使其转换字符串title带有连字符号的 URL 版本。您可以使用本节中介绍的任何方法，但不要用replace方法。以下是本次挑战的要求：

输入包含空格和标题大小写单词的字符串

输出字符串，单词之间的空格用连字符(-)替换

输出应该是小写字母

输出不应有任何空格

## 21.使用 every 方法检查数组中的每个元素是否符合条件

every方法用于检测数组中所有元素是否都符合指定条件。如果所有元素满足条件，返回布尔值true，反之返回false。

举个例子，下面的代码检测数组numbers的所有元素是否都小于 10：
```js
var numbers = [1, 5, 8, 0, 10, 11];
numbers.every(function(currentValue) {
  return currentValue < 10;
});
// 返回 false
```

## 22.使用 some 方法检查数组中是否有元素是否符合条件

some方法用于检测数组中任何元素是否满足指定条件。如果有一个元素满足条件，返回布尔值true，反之返回false。

举个例子，下面的代码检测数组numbers中是否有元素小于10：
```js
var numbers = [10, 50, 8, 220, 110, 11];
numbers.some(function(currentValue) {
  return currentValue < 10;
});
// 返回 true
```

## 23.函数柯里化

`arity`是函数所需的形参的数量。函数`Currying`意思是把接受多个`arity`的函数变换成接受单一`arity`的函数。

换句话说，就是重构函数让它接收一个参数，然后返回接收下一个参数的函数，依此类推。

举个例子：
```js
//Un-curried function
function unCurried(x, y) {
  return x + y;
}

// 柯里化函数
function curried(x) {
  return function(y) {
    return x + y;
  }
}
curried(1)(2) // 返回 3
```
柯里化在不能一次为函数提供所有参数情况下很有用。因为它可以将每个函数的调用保存到一个变量中，该变量将保存返回的函数引用，该引用在下一个参数可用时接受该参数。下面是使用curried函数的例子：
```js
// Call a curried function in parts:
var funcForY = curried(1);
console.log(funcForY(2)); // 打印 3
```
类似地，`partial application`的意思是一次对一个函数应用几个参数，然后返回另一个应用更多参数的函数。

举个例子：
```js
//Impartial function
function impartial(x, y, z) {
  return x + y + z;
}
var partialFn = impartial.bind(this, 1, 2);
partialFn(10); // 返回 13
```
